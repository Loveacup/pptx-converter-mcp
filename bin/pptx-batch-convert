#!/opt/homebrew/bin/python3.11
"""
MCP å·¥å…·ï¼šPPT æ‰¹é‡è½¬ Markdownï¼ˆå¸¦å›¾ç‰‡æè¿°ï¼‰
æ”¯æŒå¤šç§ Vision LLM åç«¯

ç”¨æ³•:
    python pptx_batch_converter.py <input_dir> [output_dir]
"""
import os
import sys
import json
import base64
import zipfile
import hashlib
import requests
import re
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Optional, Tuple

# é…ç½®
MAX_WORKERS = int(os.environ.get("MAX_WORKERS", "3"))
CACHE_DIR = Path(os.environ.get("CACHE_DIR", "/tmp/ppt_image_cache"))

def load_config():
    """åŠ è½½ LLM é…ç½®ï¼ŒéªŒè¯å¿…éœ€çš„ç¯å¢ƒå˜é‡"""
    api_url = os.environ.get("LLM_API_URL")
    api_key = os.environ.get("LLM_API_KEY")
    model = os.environ.get("LLM_MODEL")

    if not api_url or not model:
        print("âŒ Error: LLM_API_URL and LLM_MODEL must be set", file=sys.stderr)
        print("", file=sys.stderr)
        print("Please copy .env.example to .env and configure your LLM settings,", file=sys.stderr)
        print("or set environment variables:", file=sys.stderr)
        print("  export LLM_API_URL=your-api-url", file=sys.stderr)
        print("  export LLM_API_KEY=your-api-key  # if required by your provider", file=sys.stderr)
        print("  export LLM_MODEL=your-model-name", file=sys.stderr)
        print("", file=sys.stderr)
        print("Examples:", file=sys.stderr)
        print("  # OpenAI", file=sys.stderr)
        print("  export LLM_API_URL=https://api.openai.com/v1/chat/completions", file=sys.stderr)
        print("  export LLM_API_KEY=sk-...", file=sys.stderr)
        print("  export LLM_MODEL=gpt-4o", file=sys.stderr)
        print("", file=sys.stderr)
        print("  # Local model (vLLM, Ollama, etc.)", file=sys.stderr)
        print("  export LLM_API_URL=http://localhost:8000/v1/chat/completions", file=sys.stderr)
        print("  export LLM_MODEL=your-model-name", file=sys.stderr)
        sys.exit(1)

    return api_url, api_key, model

API_URL, API_KEY, MODEL = load_config()

def ensure_cache_dir():
    CACHE_DIR.mkdir(parents=True, exist_ok=True)

def get_cache_path(pptx_path: Path) -> Path:
    pptx_hash = hashlib.md5(pptx_path.read_bytes()).hexdigest()[:16]
    return CACHE_DIR / f"{pptx_path.stem}_{pptx_hash}.json"

def load_cache(cache_path: Path) -> Dict:
    if cache_path.exists():
        with open(cache_path, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_cache(cache_path: Path, data: Dict):
    with open(cache_path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def describe_image(image_path: Path) -> Optional[str]:
    try:
        with open(image_path, "rb") as f:
            img_data = f.read()
        
        img_base64 = base64.b64encode(img_data).decode('utf-8')
        ext = image_path.suffix[1:] if image_path.suffix else 'png'
        
        payload = {
            "model": MODEL,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": "è¯·ç”¨ä¸­æ–‡è¯¦ç»†æè¿°è¿™å¼ å›¾ç‰‡çš„å†…å®¹ã€‚å¦‚æœæ˜¯å›¾è¡¨ï¼Œè¯·è¯´æ˜å›¾è¡¨ç±»å‹ã€æ•°æ®è¶‹åŠ¿ï¼›å¦‚æœæ˜¯ç•Œé¢æˆªå›¾ï¼Œè¯·æè¿°ç•Œé¢å¸ƒå±€å’ŒåŠŸèƒ½ï¼›å¦‚æœæ˜¯å›¾æ ‡ï¼Œè¯·æè¿°å›¾æ ‡æ ·å¼å’Œå«ä¹‰ã€‚æ§åˆ¶åœ¨100å­—ä»¥å†…ã€‚"
                        },
                        {
                            "type": "image_url",
                            "image_url": {"url": f"data:image/{ext};base64,{img_base64}"}
                        }
                    ]
                }
            ],
            "max_tokens": 200,
            "temperature": 0.3
        }
        
        headers = {"Content-Type": "application/json"}
        if API_KEY:
            headers["Authorization"] = f"Bearer {API_KEY}"
        
        response = requests.post(
            API_URL,
            headers=headers,
            json=payload,
            timeout=60
        )
        response.raise_for_status()
        result = response.json()
        return result['choices'][0]['message']['content'].strip()
        
    except Exception as e:
        return f"[å›¾ç‰‡æè¿°ç”Ÿæˆå¤±è´¥: {e}]"

def extract_images_from_pptx(pptx_path: Path, extract_dir: Path) -> List[Path]:
    """ä» PPT ä¸­æå–æ‰€æœ‰å›¾ç‰‡ï¼Œä¿æŒåŸå§‹æ–‡ä»¶å"""
    images = []
    supported_ext = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp'}
    
    try:
        with zipfile.ZipFile(pptx_path, 'r') as z:
            media_files = [f for f in z.namelist() if f.startswith('ppt/media/')]
            
            for media_file in media_files:
                file_ext = Path(media_file).suffix.lower()
                if file_ext not in supported_ext:
                    continue
                    
                file_data = z.read(media_file)
                filename = Path(media_file).name
                output_path = extract_dir / filename
                
                with open(output_path, 'wb') as f:
                    f.write(file_data)
                
                images.append(output_path)
    
    except Exception as e:
        print(f"âš ï¸  æå–å›¾ç‰‡å¤±è´¥: {e}", file=sys.stderr)
    
    return images

def build_image_number_mapping(extract_dir: Path) -> Dict[int, Path]:
    """å»ºç«‹å›¾ç‰‡åºå·åˆ°æ–‡ä»¶è·¯å¾„çš„æ˜ å°„"""
    mapping = {}
    for img_path in extract_dir.iterdir():
        if img_path.is_file():
            # æå–æ•°å­—
            match = re.search(r'\d+', img_path.stem)
            if match:
                num = int(match.group())
                mapping[num] = img_path
    return mapping

def process_images_batch(images: List[Path], cache: Dict) -> Dict[int, str]:
    """æ‰¹é‡å¤„ç†å›¾ç‰‡ï¼Œè¿”å›åºå·åˆ°æè¿°çš„æ˜ å°„"""
    descriptions = {}
    completed = 0
    failed = 0
    
    def process_single(img_path: Path) -> Tuple[int, str, bool]:
        # æå–åºå·
        match = re.search(r'\d+', img_path.stem)
        if not match:
            return 0, "", False
        img_num = int(match.group())
        
        # æ£€æŸ¥ç¼“å­˜
        cache_key = f"num_{img_num}"
        if cache_key in cache:
            return img_num, cache[cache_key], True
        
        # ç”Ÿæˆæè¿°
        desc = describe_image(img_path)
        success = not desc.startswith("[å›¾ç‰‡æè¿°ç”Ÿæˆå¤±è´¥")
        
        return img_num, desc, success
    
    print(f"ğŸ”„ å¼€å§‹è¯†åˆ« {len(images)} å¼ å›¾ç‰‡...")
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        future_to_image = {executor.submit(process_single, img): img for img in images}
        
        for future in as_completed(future_to_image):
            img_path = future_to_image[future]
            try:
                img_num, description, success = future.result()
                if img_num == 0:
                    continue
                    
                descriptions[img_num] = description
                
                if success:
                    completed += 1
                    cache[f"num_{img_num}"] = description
                else:
                    failed += 1
                
                progress = (completed + failed) / len(images) * 100
                print(f"\r   â³ è¿›åº¦: {completed+failed}/{len(images)} ({progress:.1f}%) - image{img_num}", 
                      end='', flush=True)
                
            except Exception as e:
                failed += 1
                print(f"\n   âŒ å¤±è´¥: {img_path.name} - {e}", file=sys.stderr)
    
    print(f"\n   âœ… å®Œæˆ: {completed}æˆåŠŸ, {failed}å¤±è´¥")
    return descriptions

def integrate_descriptions(content: str, descriptions: Dict[int, str]) -> str:
    """å°†å›¾ç‰‡æè¿°æ•´åˆåˆ° Markdown å†…å®¹ä¸­"""
    # æŸ¥æ‰¾æ‰€æœ‰å›¾ç‰‡å¼•ç”¨
    img_pattern = r'!\[([^\]]*)\]\(([^)]+)\)'
    
    def replace_with_description(match):
        alt_text = match.group(1)
        img_path = match.group(2)
        full_match = match.group(0)
        
        # æå–å›¾ç‰‡ç¼–å·
        num_match = re.search(r'\d+', Path(img_path).stem)
        if not num_match:
            return full_match
        
        img_num = int(num_match.group())
        
        # æŸ¥æ‰¾å¯¹åº”çš„æè¿°
        if img_num in descriptions:
            desc = descriptions[img_num]
            desc_block = f"\n\n> ğŸ–¼ï¸ **å›¾ç‰‡æè¿°**: {desc[:150]}"
            if len(desc) > 150:
                desc_block += "..."
            return full_match + desc_block
        
        return full_match
    
    return re.sub(img_pattern, replace_with_description, content)

def convert_single_pptx(pptx_path: Path, output_dir: Path) -> Path:
    """è½¬æ¢å•ä¸ª PPT"""
    output_path = output_dir / f"{pptx_path.stem}.md"
    
    ensure_cache_dir()
    cache_path = get_cache_path(pptx_path)
    cache = load_cache(cache_path)
    
    print(f"\nğŸ“„ å¤„ç†: {pptx_path.name}")
    
    # æ­¥éª¤ 1: æå–å›¾ç‰‡
    extract_dir = CACHE_DIR / f"{pptx_path.stem}_images"
    extract_dir.mkdir(exist_ok=True)
    
    images = extract_images_from_pptx(pptx_path, extract_dir)
    if not images:
        print("   âš ï¸  æœªæ‰¾åˆ°å›¾ç‰‡")
        descriptions = {}
    else:
        print(f"   ğŸ–¼ï¸  æ‰¾åˆ° {len(images)} å¼ å›¾ç‰‡")
        descriptions = process_images_batch(images, cache)
        save_cache(cache_path, cache)
    
    # æ­¥éª¤ 2: è½¬æ¢åŸºç¡€å†…å®¹
    print("   ğŸ“ è½¬æ¢åŸºç¡€å†…å®¹...")
    try:
        from markitdown import MarkItDown
        md = MarkItDown()
        result = md.convert(str(pptx_path))
        content = result.text_content
    except ImportError:
        print("   âš ï¸  markitdown æœªå®‰è£…ï¼Œä»…ç”Ÿæˆå›¾ç‰‡æè¿°åˆ—è¡¨")
        content = f"# {pptx_path.stem}\n\n"
    
    # æ­¥éª¤ 3: æ•´åˆå›¾ç‰‡æè¿°
    if descriptions:
        print(f"   ğŸ”— æ•´åˆ {len(descriptions)} ä¸ªå›¾ç‰‡æè¿°...")
        content = integrate_descriptions(content, descriptions)
    
    # æ­¥éª¤ 4: ä¿å­˜
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"   âœ… è¾“å‡º: {output_path.name}")
    return output_path

def batch_convert(input_dir: Path, output_dir: Path):
    """æ‰¹é‡è½¬æ¢ç›®å½•ä¸­çš„æ‰€æœ‰ PPT"""
    if not input_dir.exists():
        raise FileNotFoundError(f"è¾“å…¥ç›®å½•ä¸å­˜åœ¨: {input_dir}")
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # æŸ¥æ‰¾æ‰€æœ‰ PPT
    pptx_files = sorted(input_dir.glob("*.pptx"))
    
    if not pptx_files:
        print(f"âŒ æœªåœ¨ {input_dir} æ‰¾åˆ° .pptx æ–‡ä»¶")
        return
    
    print("=" * 70)
    print("ğŸš€ PPT æ‰¹é‡è½¬ Markdownï¼ˆMCP å·¥å…·ï¼‰")
    print(f"   æ¨¡å‹: {MODEL}")
    print(f"   å¹¶å‘: {MAX_WORKERS}")
    print("=" * 70)
    print(f"\nğŸ“ æ‰¾åˆ° {len(pptx_files)} ä¸ªPPTæ–‡ä»¶")
    print(f"ğŸ“‚ è¾“å‡ºç›®å½•: {output_dir}\n")
    
    # é€ä¸ªå¤„ç†
    success_count = 0
    failed_count = 0
    
    for idx, pptx_file in enumerate(pptx_files, 1):
        print(f"\n{'='*70}")
        print(f"ğŸ“Š è¿›åº¦: [{idx}/{len(pptx_files)}]")
        print('='*70)
        
        try:
            convert_single_pptx(pptx_file, output_dir)
            success_count += 1
        except Exception as e:
            print(f"âŒ å¤±è´¥: {e}")
            failed_count += 1
    
    # ç»Ÿè®¡
    print(f"\n{'='*70}")
    print("ğŸ‰ æ‰¹é‡è½¬æ¢å®Œæˆï¼")
    print(f"   âœ… æˆåŠŸ: {success_count}")
    print(f"   âŒ å¤±è´¥: {failed_count}")
    print(f"   ğŸ“‚ è¾“å‡º: {output_dir}")
    print('='*70)

def main():
    if len(sys.argv) < 2:
        print("ç”¨æ³•: python pptx_batch_converter.py <input_dir> [output_dir]")
        print("")
        print("å‚æ•°:")
        print("  input_dir   - è¾“å…¥ç›®å½•ï¼ˆåŒ…å« .pptx æ–‡ä»¶ï¼‰")
        print("  output_dir  - è¾“å‡ºç›®å½•ï¼ˆé»˜è®¤: input_dir/../Markdownï¼‰")
        print("")
        print("ç¯å¢ƒå˜é‡ (å¿…éœ€):")
        print("  LLM_API_URL  - LLM API ç«¯ç‚¹")
        print("  LLM_MODEL    - æ¨¡å‹åç§°")
        print("")
        print("ç¯å¢ƒå˜é‡ (å¯é€‰):")
        print("  LLM_API_KEY  - API å¯†é’¥")
        print("  MAX_WORKERS  - å¹¶å‘æ•° (é»˜è®¤: 3)")
        print("  CACHE_DIR    - ç¼“å­˜ç›®å½• (é»˜è®¤: /tmp/ppt_image_cache)")
        print("")
        print("è¯¦è§ .env.example é…ç½®ç¤ºä¾‹")
        sys.exit(1)
    
    input_dir = Path(sys.argv[1])
    
    if len(sys.argv) > 2:
        output_dir = Path(sys.argv[2])
    else:
        output_dir = input_dir.parent / "Markdown"
    
    try:
        batch_convert(input_dir, output_dir)
    except KeyboardInterrupt:
        print("\n\nâš ï¸  ç”¨æˆ·ä¸­æ–­")
        sys.exit(0)
    except Exception as e:
        print(f"\nâŒ é”™è¯¯: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
